module main {

    type task_t = enum { NULL, rxn_0, rxn_1, rxn_2, rxn_3 };
    // Should be set to the number of reactions in the system.
    type schedule_t = { task_t, task_t, task_t, task_t };
    type workers_t = { schedule_t, schedule_t };

    group indices : integer = { 1, 2, 3, 4 };
    group worker_indices : integer = { 1, 2 };

    // Assume all triggers are present.
    group current_task_set : task_t = { rxn_0, rxn_1, rxn_2, rxn_3 };

    var workers : workers_t;

    // Get a task from a worker schedule.
    define getT(s : schedule_t, i : integer) : task_t
        = if (i == 1) then s._1 else 
            (if (i == 2) then s._2 else
                (if (i == 3) then s._3 else
                    (if (i == 4) then s._4 else NULL)));

    // Get a worker from workers.
    define getW(workers : workers_t, w : integer) : schedule_t
        = if (w == 1) then workers._1 else workers._2;

    // Condense the two getters above.
    define get(w, i : integer) : task_t
        = getT(getW(workers, w), i);

    /* Constraints */
    // The schedules cannot be all empty.
    axiom(finite_exists (w : integer) in worker_indices ::
        (finite_exists (i : integer) in indices ::
            get(w, i) != NULL));

    // Each reaction only appears once.
    axiom(finite_forall (w1: integer) in worker_indices ::
        (finite_forall (w2 : integer) in worker_indices ::
        (finite_forall (i : integer) in indices ::
        (finite_forall (j : integer) in indices ::
            (get(w1, i) != NULL)
            ==> ((w1 == w2 && i == j) <==> 
            (get(w1, i) == get(w2, j)))
        ))));

    // Each reaction appears at least once.
    axiom(finite_forall (task : task_t) in current_task_set ::
        (finite_exists (w : integer) in worker_indices ::
        (finite_exists (i : integer) in indices ::
            get(w, i) == task
        )));

    // Dependency graph (DAG) with reactions as nodes and
    // precedence relations as edges.
    define precedes(t1, t2 : task_t) : boolean
    = (t1 == rxn_0 && t2 == rxn_1)
        || (t1 == rxn_2 && t2 == rxn_3); 
    
    // The worker schedules need to respect the dependency graph.
    axiom(finite_forall (w1: integer) in worker_indices ::
        (finite_forall (w2 : integer) in worker_indices ::
        (finite_forall (i : integer) in indices ::
        (finite_forall (j : integer) in indices ::
            (precedes(get(w1, i), get(w2, j))) ==> (i < j)
        ))));

    //// Generate a satisfiable schedule.
    property test : !(true);

    //// Optimization 1: load balancing
    define count(s : schedule_t) : integer
    = (if (getT(s, 1) != NULL) then 1 else 0)
        + (if (getT(s, 2) != NULL) then 1 else 0)
        + (if (getT(s, 3) != NULL) then 1 else 0)
        + (if (getT(s, 4) != NULL) then 1 else 0);
    var count_w1 : integer;
    var count_w2 : integer;
    axiom(count_w1 == count(getW(workers, 1)));
    axiom(count_w2 == count(getW(workers, 2)));
    
    // Try to minimize the abs of DIFF. 
    // (minimize (abs initial_2_DIFF))
    // (get-objectives)
    var DIFF : integer;
    define load_balanced() : boolean =
        count_w1 == count_w2 + DIFF;

    // Generate a satisfiable schedule with opti. 1.
    property opt1 : !(load_balanced());

    //// Optimization 2: spatial & temporal locality
    group tasks_r1 : task_t = { rxn_0 };
    group tasks_r2 : task_t = { rxn_1, rxn_2 };
    group tasks_r3 : task_t = { rxn_3 };
    var tasks_r1_num_workers : integer; 
    var tasks_r2_num_workers : integer; 
    var tasks_r3_num_workers : integer; 
    // R1
    define worker_schedule_contains_tasks_r1(s : schedule_t) : boolean
    = (finite_exists (i : integer) in indices :: (
        finite_exists (t : task_t) in tasks_r1 :: (
            getT(s, i) == t
        )));
    define get_tasks_r1_num_workers() : integer
    = (if (worker_schedule_contains_tasks_r1(getW(workers, 1))) then 1 else 0)
    + (if (worker_schedule_contains_tasks_r1(getW(workers, 2))) then 1 else 0);
    axiom(tasks_r1_num_workers == get_tasks_r1_num_workers());
    // R2
    define worker_schedule_contains_tasks_r2(s : schedule_t) : boolean
    = (finite_exists (i : integer) in indices :: (
        finite_exists (t : task_t) in tasks_r2 :: (
            getT(s, i) == t
        )));
    define get_tasks_r2_num_workers() : integer
    = (if (worker_schedule_contains_tasks_r2(getW(workers, 1))) then 1 else 0)
    + (if (worker_schedule_contains_tasks_r2(getW(workers, 2))) then 1 else 0);
    axiom(tasks_r2_num_workers == get_tasks_r2_num_workers());
    // R3
    define worker_schedule_contains_tasks_r3(s : schedule_t) : boolean
    = (finite_exists (i : integer) in indices :: (
        finite_exists (t : task_t) in tasks_r3 :: (
            getT(s, i) == t
        )));
    define get_tasks_r3_num_workers() : integer
    = (if (worker_schedule_contains_tasks_r3(getW(workers, 1))) then 1 else 0)
    + (if (worker_schedule_contains_tasks_r3(getW(workers, 2))) then 1 else 0);
    axiom(tasks_r3_num_workers == get_tasks_r3_num_workers());

    // Try to minimize the number of workers
    // each task set is scattered across.
    // (minimize (abs initial_8_num_workers_sum))
    // (get-objectives)
    var num_workers_sum : integer;

    // This macro acts as a switch for this optimization.
    define locality() : boolean
    = (num_workers_sum ==
        tasks_r1_num_workers
        + tasks_r2_num_workers
        + tasks_r3_num_workers);

    // Generate a satisfiable schedule with opti. 2.
    property opt2 : !(locality());

    // Generate a satisfiable schedule with opt. 1 & 2.
    property opt_both : !(load_balanced() && locality());

    control {
        v = unroll(0);
        check;
        print_results;
        v.print_cex;
    }
}
